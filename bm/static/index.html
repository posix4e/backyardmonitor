
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Backyard Monitor</title>
    <style>
      .muted { color:#666; }
      label { display:block; margin-top:6px; }
      input[type=number] { width: 6em; }
      .tooltip { position:absolute; background:#fff; border:1px solid #ccc; border-radius:8px; box-shadow:0 2px 12px rgba(0,0,0,0.12); padding:6px 8px; display:none; z-index:1000; pointer-events:auto; }
      .tooltip button { margin-right:6px; }
      .pulse-indicator { position:absolute; border-radius:6px; box-shadow:0 0 0 2px rgba(255,0,0,0.5), 0 0 18px rgba(255,0,0,0.35); animation:pulse 1s ease-out infinite; pointer-events:none; z-index:9; }
      @keyframes pulse { 0%{ box-shadow:0 0 0 2px rgba(255,0,0,0.6), 0 0 0 rgba(255,0,0,0.0);} 70%{ box-shadow:0 0 0 6px rgba(255,0,0,0.2), 0 0 18px rgba(255,0,0,0.4);} 100%{ box-shadow:0 0 0 2px rgba(255,0,0,0.6), 0 0 0 rgba(255,0,0,0.0);} }
      .change-button { position:absolute; right:6px; top:6px; cursor:pointer; }
      .change-button.star { width:28px; height:28px; border:none; border-radius:50%;
        display:flex; align-items:center; justify-content:center;
        background: conic-gradient(#ff0040, #ff7a00, #ffd400, #38e600, #00d5ff, #6733ff, #ff33cc, #ff0040);
        color:#ffffff; font-size:16px; line-height:1; box-shadow:0 2px 8px rgba(0,0,0,0.25); }
      .compare-popup { position:absolute; background:#fff; border:1px solid #ccc; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.2); padding:8px; z-index:20; }
      .compare-popup .row { display:flex; gap:8px; }
      .compare-popup img { max-width:220px; border-radius:6px; border:1px solid #eee; }
      .compare-close { position:absolute; right:6px; top:6px; background:transparent; border:none; font-size:14px; cursor:pointer; }
      .delta-badge { position:absolute; left:6px; top:6px; background:#111; color:#fff; font-size:11px; padding:2px 6px; border-radius:10px; opacity:0.85; }
      #canvasWrap { position: relative; display: inline-block; }
    </style>
  </head>
  <body>
    <h1>Backyard Monitor</h1>
    <div class="controls">
      <button id="btnStart" onclick="control('start')">Start</button>
      <button id="btnStop" onclick="control('stop')">Stop</button>
      <span class="muted">Spots: click to add; click to select; arrows to nudge; Delete to remove.</span>
    </div>
    <div class="row" style="margin-top:12px;">
      <div class="card">
        <div><strong>Live Frame</strong></div>
        <div id="canvasWrap">
          <canvas id="canvas" width="640" height="360"></canvas>
          <div id="spotToolbar" class="tooltip"></div>
        </div>
        <div class="muted" id="status"></div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap: wrap;">
          <button onclick="saveZones()">Save Zones</button>
          <button onclick="clearSpots()">Clear Spots</button>
          <button id="sizeBtn" onclick="toggleSize()">Expand</button>
          <button id="annoBtn" onclick="toggleAnno()">Hide Annotations</button>
        </div>
        
      </div>
      <div class="card" style="min-width:420px;">
        <div style="display:flex; gap:8px; margin-bottom:8px;">
          <div><strong>Data</strong></div>
        </div>
        <div id="panel_data">
        <div><strong>Data</strong></div>
        <div style="margin-top:8px;">
          <label for="zones_json" style="font-weight:600; margin-bottom:4px; display:block;">Zones (JSON)</label>
          <textarea id="zones_json" aria-label="Zones JSON" style="width: 380px; height: 180px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;"></textarea>
          <div style="margin-top:6px; display:flex; gap:8px; flex-wrap: wrap;">
            <button onclick="loadZonesJson()">Load Zones</button>
            <button onclick="saveZonesJson()">Save Zones</button>
          </div>
        </div>
        <div style="margin-top:16px;">
          <div style="font-weight:600; margin-bottom:4px;">Events</div>
          <div style="margin-bottom:6px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <button onclick="loadEvents()">Load Events</button>
            <label for="events_limit">Limit</label>
            <input type="number" id="events_limit" name="events_limit" value="50" min="1" style="width:70px;"/>
            <button style="margin-left:auto; color:#a00;" onclick="clearAllEvents()">Clear Events</button>
          </div>
          <div id="events_list" style="max-height:180px; overflow:auto; border:1px solid #eee; padding:6px; border-radius:6px;"></div>
          <div id="event_editor" style="margin-top:8px; display:none;">
            <div style="margin-bottom:4px;">Editing Event <span id="ev_id"></span></div>
            <label for="ev_kind">Kind</label>
            <input type="text" id="ev_kind" name="ev_kind" style="width:200px;"/>
            <label for="ev_ts">Timestamp</label>
            <input type="number" step="0.001" id="ev_ts" name="ev_ts" style="width:200px;"/>
            <label for="ev_meta">Meta (JSON)</label>
            <textarea id="ev_meta" name="ev_meta" style="width: 380px; height: 120px; font-family: ui-monospace, monospace;"></textarea>
            <div style="margin-top:6px; display:flex; gap:8px;">
              <button onclick="saveEvent()">Save Event</button>
              <button onclick="deleteEvent()" style="color:#b00000;">Delete Event</button>
            </div>
          </div>
        </div>
        <div style="margin-top:16px;">
          <div style="font-weight:600; margin-bottom:4px;">Perception</div>
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <label for="phash_bits">Min bits</label>
            <input type="number" id="phash_bits" name="phash_bits" value="14" min="0" max="64" style="width:80px;"/>
            <label for="phash_ms">Stable ms</label>
            <input type="number" id="phash_ms" name="phash_ms" value="1200" min="0" style="width:100px;"/>
            <button onclick="savePerception()">Apply</button>
          </div>
        </div>
        <div style="margin-top:16px;">
          <div style="font-weight:600; margin-bottom:4px;">Images</div>
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:6px;">
            <button onclick="loadImagesSummary()">Refresh Summary</button>
            <button onclick="cleanupOrphans()">Cleanup Orphans</button>
            <button onclick="loadThumbnails()">Show Latest Thumbnails</button>
          </div>
          <div id="images_summary" class="muted"></div>
          <div id="thumb_grid" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:8px; max-height:320px; overflow:auto;"></div>
        </div>
        </div>
        </div>
        </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      let spots = []; // [{id,name,polygon:[[x,y],...]}]
      let selectedSpotId = null;
      const DEFAULT_SPOT = { w: 120, h: 200 };
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const canvasWrap = document.getElementById('canvasWrap');
      const spotToolbar = document.getElementById('spotToolbar');
      let showOverlays = true;
      let baseW = 0, baseH = 0; // native frame size from backend
      const initW = canvas.width, initH = canvas.height; // initial canvas size (shrink target)
      let expanded = false; // false => 640x360, true => full native size
      let hoverSpotId = null; // track hover for selection hint

      function applySize(){
        // If expanded and we know native size, use it; otherwise stay at initial size
        if (expanded && baseW && baseH){
          canvas.width = baseW;
          canvas.height = baseH;
        } else {
          canvas.width = initW;
          canvas.height = initH;
        }
        const btn = document.getElementById('sizeBtn');
        if (btn) btn.textContent = expanded ? 'Shrink' : 'Expand';
      }

      async function control(action) {
        const bStart = document.getElementById('btnStart');
        const bStop = document.getElementById('btnStop');
        try {
          if (bStart) bStart.disabled = true;
          if (bStop) bStop.disabled = true;
          const res = await fetch('/api/control?action=' + encodeURIComponent(action), { method: 'POST' });
          if (!res.ok) {
            const txt = await res.text();
            alert('Control failed: ' + txt);
          }
          // give the worker a moment to spin up/down
          await new Promise(r => setTimeout(r, 400));
          await refresh();
        } catch (e) {
          console.error(e);
          alert('Control error: ' + (e && e.message ? e.message : e));
        } finally {
          if (bStart) bStart.disabled = false;
          if (bStop) bStop.disabled = false;
        }
      }
      async function refresh() {
        const status = await (await fetch('/api/status')).json();
        document.getElementById('status').innerText = `running=${status.running} last_ts=${status.last_ts} size=${status.width}x${status.height}`;
        if (status.width && status.height) {
          baseW = status.width; baseH = status.height;
        }
        // Apply the current sizing preference
        applySize();
      }

      function rectPolygon(cx, cy, w, h) {
        const x0 = cx - w/2, y0 = cy - h/2;
        return [ [x0,y0], [x0+w,y0], [x0+w,y0+h], [x0,y0+h] ];
      }
      function pointInPoly(pt, poly) {
        let [x, y] = pt; let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i][0], yi = poly[i][1];
          const xj = poly[j][0], yj = poly[j][1];
          const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function deleteSelected(){
        if (!selectedSpotId) return;
        spots = spots.filter(sp => sp.id !== selectedSpotId);
        selectedSpotId = null;
        updateToolbar();
        draw();
      }

      function rotateSelected(deg){
        if (!selectedSpotId) return;
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (!s || !s.polygon || s.polygon.length < 3) return;
        const xs = s.polygon.map(p=>p[0]); const ys = s.polygon.map(p=>p[1]);
        const cx = (Math.min(...xs) + Math.max(...xs)) / 2;
        const cy = (Math.min(...ys) + Math.max(...ys)) / 2;
        const ang = (deg * Math.PI) / 180;
        const ca = Math.cos(ang), sa = Math.sin(ang);
        s.polygon = s.polygon.map(([px,py]) => {
          const dx = px - cx, dy = py - cy;
          const rx = dx*ca - dy*sa; const ry = dx*sa + dy*ca;
          return [cx + rx, cy + ry];
        });
        updateToolbar();
        draw();
      }

      function updateSpotName(name){
        if (!selectedSpotId) return;
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (s) { s.name = (name || '').trim() || s.id; updateToolbar(); draw(); }
      }

      function selectedBBox(){
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (!s || !s.polygon || s.polygon.length < 3) return null;
        const xs = s.polygon.map(p=>p[0]); const ys = s.polygon.map(p=>p[1]);
        const x1 = Math.min(...xs), x2 = Math.max(...xs), y1 = Math.min(...ys), y2 = Math.max(...ys);
        return { x: x1, y: y1, w: x2-x1, h: y2-y1, name: s.name || s.id };
      }

      function updateToolbar(){
        // Hide toolbar entirely when overlays are hidden
        if (!showOverlays) {
          spotToolbar.style.display = 'none';
          window.__tb_last_id = null;
          return;
        }
        const box = selectedBBox();
        if (!box){ spotToolbar.style.display = 'none'; window.__tb_last_id=null; return; }
        spotToolbar.style.display = 'block';
        // Anchor toolbar near selected polygon centroid (clamped within canvas)
        try {
          if (baseW && baseH) {
            const r = bboxToScreen(Math.round(box.x), Math.round(box.y), Math.round(box.x+box.w), Math.round(box.y+box.h));
            const tbW = Math.min(360, canvas.width - 16);
            const left = Math.max(8, Math.min(canvas.width - tbW - 8, Math.round(r.x + r.w/2 - 120)));
            const top = Math.max(8, Math.min(canvas.height - 48, Math.round(r.y - 36)));
            spotToolbar.style.left = left + 'px';
            spotToolbar.style.top = top + 'px';
            spotToolbar.style.maxWidth = tbW + 'px';
          } else {
            spotToolbar.style.left = '8px';
            spotToolbar.style.top = '8px';
          }
        } catch(e) {
          spotToolbar.style.left = '8px';
          spotToolbar.style.top = '8px';
        }
        if (window.__tb_last_id === selectedSpotId){ return; }
        window.__tb_last_id = selectedSpotId;
        const safe = (s) => String(s||'').replace(/[&<>]/g, (c)=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]||c));
          spotToolbar.innerHTML = `
            <div style="display:flex; align-items:center; gap:6px;">
              <input class="tb_name" name="spot_name" aria-label="Spot name" type="text" value="${safe(box.name)}" style="max-width:120px;"/>
              <span class="muted" style="font-size:12px;">${Math.round(box.w)}×${Math.round(box.h)} px</span>
              <label style="font-size:12px;">Min bits <input class="tb_minbits" name="min_bits" type="number" style="width:64px;"/></label>
              <label style="font-size:12px;">Stable ms <input class="tb_stable" name="stable_ms" type="number" style="width:80px;"/></label>
              <button class="tb_compare" title="Compare (prev vs current)">★</button>
              <button class="tb_suggest" title="Suggest values based on size">Suggest</button>
              <button class="tb_save">Save</button>
              <button class="tb_rn">-10°</button>
              <button class="tb_rp">+10°</button>
              <button class="tb_del" style="color:#a00;">Delete</button>
            </div>`;
          const nameEl = spotToolbar.querySelector('.tb_name');
          const minEl = spotToolbar.querySelector('.tb_minbits');
          const stEl = spotToolbar.querySelector('.tb_stable');
          const cmpEl = spotToolbar.querySelector('.tb_compare');
          const suggestEl = spotToolbar.querySelector('.tb_suggest');
          if (cmpEl) cmpEl.onclick = (e) => {
            try {
              e.stopPropagation();
              const r = bboxToScreen(Math.round(box.x), Math.round(box.y), Math.round(box.x+box.w), Math.round(box.y+box.h));
              const sid = selectedSpotId;
              const prevUrl = (window.spotPrev && window.spotPrev[sid]) || null;
              const curUrl = `/api/spot.jpg?id=${encodeURIComponent(sid)}&w=240&ts=${Date.now()}`;
              const prevSig = (window.spotPrevSig && window.spotPrevSig[sid]) || null;
              const curSig = (window.lastSigMap && window.lastSigMap[sid]) || null;
              showComparisonPopup(sid, r || {x:0,y:0,w:0,h:0}, prevUrl, curUrl, prevSig, curSig);
            } catch(err) { console.error(err); }
          };
          const saveEl = spotToolbar.querySelector('.tb_save');
        const rnEl = spotToolbar.querySelector('.tb_rn');
        const rpEl = spotToolbar.querySelector('.tb_rp');
        const delEl = spotToolbar.querySelector('.tb_del');
        // preload per-spot overrides from current zones data if available
        (async () => {
          try {
            const z = await (await fetch('/api/zones')).json();
            const cfg = (z.spots||[]).find(sp=>sp.id===selectedSpotId) || {};
            if (minEl) minEl.value = cfg.min_bits != null ? cfg.min_bits : '';
            if (stEl) stEl.value = cfg.stable_ms != null ? cfg.stable_ms : '';
          } catch(e) {}
        })();
        if (suggestEl) suggestEl.onclick = () => {
          try {
            // Estimate area fraction to suggest thresholds
            const totalW = baseW || initW;
            const totalH = baseH || initH;
            const frac = (box.w * box.h) / Math.max(1, totalW * totalH);
            let sugBits;
            if (frac < 0.005) sugBits = 10;       // < 0.5%
            else if (frac < 0.02) sugBits = 12;   // < 2%
            else if (frac < 0.06) sugBits = 14;   // < 6%
            else if (frac < 0.15) sugBits = 16;   // < 15%
            else sugBits = 18;                    // larger regions
            const sugStable = frac < 0.02 ? 1800 : (frac < 0.06 ? 1500 : 1200);
            if (minEl) minEl.value = sugBits;
            if (stEl) stEl.value = sugStable;
          } catch(e) { console.error(e); }
        };
        if (saveEl) saveEl.onclick = async () => {
          try {
            const newName = nameEl ? (nameEl.value||'') : '';
            const minBits = minEl && minEl.value !== '' ? parseInt(minEl.value,10) : null;
            const stableMs = stEl && stEl.value !== '' ? parseInt(stEl.value,10) : null;
            const z = await (await fetch('/api/zones')).json();
            const spotsZ = z.spots || [];
            for (const sp of spotsZ){ if (sp.id === selectedSpotId){ sp.name = newName || sp.id; if (minBits!==null) sp.min_bits = minBits; else delete sp.min_bits; if (stableMs!==null) sp.stable_ms = stableMs; else delete sp.stable_ms; break; } }
            await fetch('/api/zones', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ spots: spotsZ }) });
            // update local overlay
            for (let i=0;i<spots.length;i++){ if (spots[i].id === selectedSpotId){ spots[i].name = newName || spots[i].id; break; } }
          } catch(e) { console.error(e); }
        };
        if (rnEl) rnEl.onclick = () => rotateSelected(-10);
        if (rpEl) rpEl.onclick = () => rotateSelected(10);
        if (delEl) delEl.onclick = () => deleteSelected();
      }
      window.addEventListener('resize', updateToolbar);

      function toggleSize(){
        expanded = !expanded;
        applySize();
        draw();
      }

      function toggleAnno(){
        showOverlays = !showOverlays;
        const b = document.getElementById('annoBtn');
        if (b) b.textContent = showOverlays ? 'Hide Annotations' : 'Show Annotations';
        // Hide any existing tooltips/popups and pulse indicators when disabling
        if (!showOverlays) {
          try { spotToolbar.style.display = 'none'; } catch(e){}
          try { document.querySelectorAll('.compare-popup').forEach(n=>n.remove()); } catch(e){}
          try { document.querySelectorAll('.pulse-indicator').forEach(n=>n.remove()); } catch(e){}
        }
        draw();
      }

      // Hover feedback to indicate click-to-select
      // Drag support: move whole polygon or drag vertices
      let isDragging = false;
      let dragKind = null; // 'move' | 'vertex'
      let dragStart = { x: 0, y: 0 };
      let dragSpotId = null;
      let dragVertexIndex = -1;
      let didDrag = false;

      function screenToBase(e){
        const rect = canvas.getBoundingClientRect();
        const sx = baseW ? (baseW / canvas.width) : 1;
        const sy = baseH ? (baseH / canvas.height) : 1;
        const x = Math.round((e.clientX - rect.left) * sx);
        const y = Math.round((e.clientY - rect.top) * sy);
        return { x, y };
      }

      function baseToScreen(x, y){
        const sx = baseW ? (canvas.width / baseW) : 1;
        const sy = baseH ? (canvas.height / baseH) : 1;
        return { x: x * sx, y: y * sy };
      }

      function hitVertexForSpot(spot, bx, by){
        if (!spot || !spot.polygon) return -1;
        const R = 8; // pixels in screen space
        for (let i = 0; i < spot.polygon.length; i++){
          const p = spot.polygon[i];
          const scr = baseToScreen(p[0], p[1]);
          const dx = (bx - p[0]) * (canvas.width / (baseW || canvas.width));
          const dy = (by - p[1]) * (canvas.height / (baseH || canvas.height));
          // distance in screen pixels
          const ds = Math.hypot(scr.x - baseToScreen(bx, by).x, scr.y - baseToScreen(bx, by).y);
          if (ds <= R) return i;
        }
        return -1;
      }

      canvas.addEventListener('mousedown', (e) => {
        if (!showOverlays) return;
        const { x, y } = screenToBase(e);
        const hit = (spots||[]).slice().reverse().find(s => pointInPoly([x,y], s.polygon));
        // Prefer selected spot if clicking near its vertex
        const current = selectedSpotId ? (spots||[]).find(sp=>sp.id===selectedSpotId) : null;
        let vIdx = current ? hitVertexForSpot(current, x, y) : -1;
        if (current && vIdx >= 0){
          // Drag a vertex of the selected polygon
          isDragging = true; dragKind = 'vertex'; dragSpotId = current.id; dragVertexIndex = vIdx; didDrag = false;
          dragStart = { x, y };
          e.preventDefault();
          return;
        }
        if (hit){
          // Drag entire polygon
          selectedSpotId = hit.id;
          isDragging = true; dragKind = 'move'; dragSpotId = hit.id; dragVertexIndex = -1; didDrag = false;
          dragStart = { x, y };
          updateToolbar();
          e.preventDefault();
        } else {
          // Let click handler create a new spot
          isDragging = false; dragKind = null; dragSpotId = null; dragVertexIndex = -1; didDrag = false;
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (!showOverlays) { canvasWrap.style.cursor = 'default'; return; }
        const rect = canvas.getBoundingClientRect();
        const sx = baseW ? (baseW / canvas.width) : 1;
        const sy = baseH ? (baseH / canvas.height) : 1;
        const x = Math.round((e.clientX - rect.left) * sx);
        const y = Math.round((e.clientY - rect.top) * sy);
        if (isDragging && dragSpotId){
          const s = (spots||[]).find(sp => sp.id === dragSpotId);
          if (s){
            if (dragKind === 'move'){
              const dx = x - dragStart.x;
              const dy = y - dragStart.y;
              if (dx || dy){ didDrag = true; }
              s.polygon = s.polygon.map(p => [p[0] + dx, p[1] + dy]);
              dragStart = { x, y };
              renderZonesView(); draw(); e.preventDefault(); return;
            } else if (dragKind === 'vertex' && dragVertexIndex >= 0){
              const before = s.polygon[dragVertexIndex];
              if (before[0] !== x || before[1] !== y){ didDrag = true; }
              s.polygon[dragVertexIndex] = [x, y];
              renderZonesView(); draw(); e.preventDefault(); return;
            }
          }
        }
        const hit = (spots||[]).slice().reverse().find(s => pointInPoly([x,y], s.polygon));
        const newHover = hit ? hit.id : null;
        if (newHover !== hoverSpotId){
          hoverSpotId = newHover;
          canvasWrap.style.cursor = hoverSpotId ? 'pointer' : 'default';
          draw();
        }
      });

      window.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        isDragging = false; dragKind = null; dragSpotId = null; dragVertexIndex = -1;
      });
      canvas.addEventListener('mousemove', (e) => {
        if (!showOverlays) { canvasWrap.style.cursor = 'default'; return; }
        const rect = canvas.getBoundingClientRect();
        const sx = baseW ? (baseW / canvas.width) : 1;
        const sy = baseH ? (baseH / canvas.height) : 1;
        const x = Math.round((e.clientX - rect.left) * sx);
        const y = Math.round((e.clientY - rect.top) * sy);
        const hit = (spots||[]).slice().reverse().find(s => pointInPoly([x,y], s.polygon));
        const newHover = hit ? hit.id : null;
        if (newHover !== hoverSpotId){
          hoverSpotId = newHover;
          canvasWrap.style.cursor = hoverSpotId ? 'pointer' : 'default';
          draw();
        }
      });
      canvas.addEventListener('mouseleave', () => { hoverSpotId = null; canvasWrap.style.cursor = 'default'; draw(); });


      async function draw() {
        // draw latest frame
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          // overlay spots as rectangles (respect visibility toggle)
          if (showOverlays && spots && spots.length) {
            ctx.strokeStyle = '#44aaff'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(68,170,255,0.12)';
            for (const s of spots) {
              if (!s.polygon || s.polygon.length < 4) continue;
              const sx = baseW ? (canvas.width / baseW) : 1;
              const sy = baseH ? (canvas.height / baseH) : 1;
              const p0 = s.polygon[0];
              ctx.beginPath(); ctx.moveTo(p0[0]*sx, p0[1]*sy);
              for (let i=1;i<s.polygon.length;i++){ const p = s.polygon[i]; ctx.lineTo(p[0]*sx, p[1]*sy); }
              ctx.closePath(); ctx.stroke(); ctx.fill();
              if (s.id === selectedSpotId) {
                ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2; ctx.setLineDash([6,4]);
                ctx.stroke(); ctx.setLineDash([]); ctx.strokeStyle = '#44aaff';
                // Draw vertex handles for selected polygon
                try {
                  ctx.fillStyle = '#ffaa00';
                  for (let i=0;i<s.polygon.length;i++){
                    const p = s.polygon[i];
                    const vx = p[0]*sx, vy = p[1]*sy;
                    ctx.beginPath(); ctx.arc(vx, vy, 4, 0, Math.PI*2); ctx.fill();
                  }
                  ctx.fillStyle = 'rgba(68,170,255,0.12)';
                } catch(e){}
              }
            }
          }
          updateToolbar();
        };
        img.src = '/frame.jpg?ts=' + Date.now();
      }

      canvas.addEventListener('click', async (e) => {
        if (!showOverlays) return;
        const { x, y } = screenToBase(e);
        if (didDrag){
          // Suppress click action if a drag just happened to avoid accidental create/select
          didDrag = false;
          return;
        }
        const hit = (spots||[]).slice().reverse().find(s => pointInPoly([x,y], s.polygon));
        if (hit) {
          selectedSpotId = hit.id;
          updateToolbar();
        } else {
          const id = 'spot_' + (spots.length + 1);
          let poly = rectPolygon(x, y, DEFAULT_SPOT.w, DEFAULT_SPOT.h);
          spots.push({ id, name: id, polygon: poly });
          selectedSpotId = id;
          updateToolbar();
        }
        renderZonesView();
        draw();
      });

      document.addEventListener('keydown', (e) => {
        if (!showOverlays) return;
        if (!selectedSpotId) return;
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (!s) return;
        const step = (e.shiftKey ? 10 : 5);
        if (e.key === 'Delete' || e.key === 'Backspace') {
          spots = spots.filter(sp => sp.id !== selectedSpotId);
          selectedSpotId = null; renderZonesView(); draw(); e.preventDefault(); return;
        }
        let dx = 0, dy = 0;
        if (e.key === 'ArrowLeft') dx = -step;
        else if (e.key === 'ArrowRight') dx = step;
        else if (e.key === 'ArrowUp') dy = -step;
        else if (e.key === 'ArrowDown') dy = step;
        if (dx || dy) {
          s.polygon = s.polygon.map(p => [p[0] + dx, p[1] + dy]);
          renderZonesView(); draw(); e.preventDefault();
        }
      });

      async function saveZones(){
        const payload = { spots };
        await fetch('/api/zones', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        alert('Saved');
      }

      async function loadZones(){
        const res = await fetch('/api/zones');
        const z = await res.json();
        spots = z.spots || [];
        renderZonesView();
      }

      function clearSpots(){ spots = []; selectedSpotId = null; draw(); }
      function renderZonesView(){ /* we keep homepage minimal; could add JSON preview if desired */ }

      // Slow down frame refresh to reduce flicker while editing
      if (window.__bm_drawInt) { try { clearInterval(window.__bm_drawInt); } catch (e) {} }
      window.__bm_drawInt = setInterval(() => { draw(); }, 2500);
      // Track last phash per spot for change detection
      let lastSigMap = {};
      // Cache previous image URL per spot from aggregated API
      let spotPrev = {};
      let spotPrevSig = {};
      async function refreshSpotPrev(){
        try {
          const j = await (await fetch('/api/spot_recent?per_spot=2&scan_limit=200')).json();
          const m = {};
          const m2 = {};
          for (const it of (j.items||[])){
            if (it.prev_url) m[it.spot_id] = it.prev_url;
            if (it.prev_sig) m2[it.spot_id] = it.prev_sig;
          }
          spotPrev = m; spotPrevSig = m2;
          try { window.spotPrev = spotPrev; window.spotPrevSig = spotPrevSig; } catch(e){}
        } catch(e) { /* ignore */ }
      }
      refreshSpotPrev();
      if (window.__bm_recentInt) { try { clearInterval(window.__bm_recentInt); } catch (e) {} }
      window.__bm_recentInt = setInterval(refreshSpotPrev, 10000);
      // Poll spot stats to detect changes and show effect
      if (window.__bm_statInt) { try { clearInterval(window.__bm_statInt); } catch (e) {} }
      window.__bm_statInt = setInterval(async () => {
        try {
          const stats = await (await fetch('/api/spot_stats')).json();
          const items = (stats && stats.spots) || [];
          for (const st of items){
            const prev = lastSigMap[st.id] || '';
            const cur = st.sig || '';
            if (prev && cur && prev !== cur) {
              try { showSpotChangeEffect(st); } catch (e) { console.error(e); }
            }
            if (cur) lastSigMap[st.id] = cur;
            try { window.lastSigMap = lastSigMap; } catch(e){}
          }
        } catch (e) { /* ignore transient errors */ }
      }, 2000);

      function bboxToScreen(x1,y1,x2,y2){
        if (!baseW || !baseH) return null;
        const sx = canvas.width / baseW, sy = canvas.height / baseH;
        const rx1 = Math.round(x1 * sx), ry1 = Math.round(y1 * sy);
        const rw = Math.round((x2 - x1) * sx), rh = Math.round((y2 - y1) * sy);
        return { x: rx1, y: ry1, w: rw, h: rh };
      }

      function showSpotChangeEffect(st){
        if (!showOverlays) return;
        // st has x1,y1,x2,y2 from /api/spot_stats
        const rect = bboxToScreen(st.x1, st.y1, st.x2, st.y2);
        if (!rect || rect.w <= 4 || rect.h <= 4) return;
        const el = document.createElement('div');
        el.className = 'pulse-indicator';
        el.style.left = rect.x + 'px';
        el.style.top = rect.y + 'px';
        el.style.width = Math.max(12, rect.w) + 'px';
        el.style.height = Math.max(12, rect.h) + 'px';
        canvasWrap.appendChild(el);
        // Setup auto-remove handlers first so we can safely reference cleanup/t below
        let removed = false;
        const cleanup = () => { if (!removed) { removed = true; el.remove(); } };
        let t = setTimeout(cleanup, 4000);
        el.addEventListener('mouseenter', () => { try { clearTimeout(t); } catch (e) {} });
        el.addEventListener('mouseleave', () => { t = setTimeout(cleanup, 1500); });

        // Show delta bits badge (computed from last phash vs current)
        try {
          const prevSig = (lastSigMap && lastSigMap[st.id]) || '';
          const curSig = st.sig || '';
          const d = hamming(prevSig, curSig);
          if (d !== null){
            const badge = document.createElement('div');
            badge.className = 'delta-badge';
            badge.textContent = `Δ ${d}`;
            el.appendChild(badge);
          }
        } catch(e){}
        // Compare UI is handled in the single spot toolbar (no separate star overlay)
      }

      function hamming(a, b){ if (!a || !b || a.length !== b.length) return null; let d=0; for(let i=0;i<a.length;i++){ if(a[i]!==b[i]) d++; } return d; }
      async function showComparisonPopup(spotId, rect, prevUrl=null, curUrl=null, prevSig=null, curSig=null){
        // remove existing popup
        document.querySelectorAll('.compare-popup').forEach(n=>n.remove());
        // fetch previous event (most recent) for this spot
        if (!prevUrl) {
          try {
            const j = await (await fetch(`/api/spot_history?spot_id=${encodeURIComponent(spotId)}&limit=2`)).json();
            if (j && j.items && j.items.length >= 2) {
              const prev = j.items[1];
              prevUrl = (prev && (prev.crop || prev.thumb)) || null;
            } else if (j && j.items && j.items.length === 1) {
              const prev = j.items[0];
              prevUrl = (prev && (prev.crop || prev.thumb)) || null;
            }
          } catch {}
        }
        if (!curUrl) {
          curUrl = `/api/spot.jpg?id=${encodeURIComponent(spotId)}&ts=${Date.now()}`;
        }
        const curSigEff = curSig || (lastSigMap && lastSigMap[spotId]) || '';
        const deltaBits = (prevSig && curSigEff && prevSig.length===curSigEff.length) ? hamming(prevSig, curSigEff) : null;
        const pop = document.createElement('div');
        pop.className = 'compare-popup';
        pop.style.left = Math.max(8, Math.min(canvas.width - 480, rect.x)) + 'px';
        pop.style.top = Math.max(8, Math.min(canvas.height - 260, rect.y)) + 'px';
        pop.innerHTML = `
          <button class="compare-close" title="Close">&times;</button>
          <div style="font-weight:600; margin-bottom:6px;">Spot ${spotId} change</div>
          <div class="muted" style="margin-bottom:6px;">phash prev: ${prevSig?prevSig:'-'} &bull; current: ${curSigEff?curSigEff:'-'} ${deltaBits!==null?('&bull; Delta bits: '+deltaBits):''}</div>
          <div class="row">
            <div>
              <div class="muted" style="margin-bottom:4px;">Previous</div>
              <img src="${prevUrl || ''}" alt="previous" onerror="this.style.display='none'"/>
            </div>
            <div>
              <div class="muted" style="margin-bottom:4px;">Current</div>
              <img src="${curUrl}" alt="current"/>
            </div>
          </div>`;
        const close = () => { try { pop.remove(); } catch (e) {} };
        pop.querySelector('.compare-close').addEventListener('click', close);
        // Close on outside click
        const onDoc = (e) => { if (!pop.contains(e.target)) { close(); document.removeEventListener('mousedown', onDoc); } };
        document.addEventListener('mousedown', onDoc);
        canvasWrap.appendChild(pop);
      }
      // Generic data panel helpers
      async function loadZonesJson(){
        try {
          const z = await (await fetch('/api/zones')).json();
          const ta = document.getElementById('zones_json');
          if (ta) ta.value = JSON.stringify(z, null, 2);
        } catch(e){ console.error(e); }
      }
      async function saveZonesJson(){
        try {
          const ta = document.getElementById('zones_json');
          const obj = JSON.parse(ta.value || '{}');
          await fetch('/api/zones', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(obj) });
          // also update overlay spots so canvas reflects saved data
          if (obj && Array.isArray(obj.spots)) { spots = obj.spots; selectedSpotId = null; draw(); }
          alert('Zones saved');
        } catch(e){ alert('Invalid JSON or save failed'); console.error(e); }
      }
      function renderEventsList(items){
        const el = document.getElementById('events_list');
        const safe = (t) => String(t||'').replace(/[&<>]/g, (c)=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]||c));
        el.innerHTML = (items||[]).map((it)=>{
          const ts = new Date((it.ts||0)*1000).toLocaleString();
          const hasSpot = !!(it && it.meta && it.meta.spot_id);
          const isSpotChange = String(it && it.kind || '').toLowerCase() === 'spot_change';
          const showWhy = hasSpot && isSpotChange;
          return `<div style=\"display:flex; align-items:center; gap:8px; padding:4px 0; border-bottom:1px solid #f2f2f2;\">`
            + `<span style=\"width:56px;\">#${it.id}</span>`
            + `<span style=\"flex:1;\">${safe(it.kind)}</span>`
            + `<span class=\"muted\" style=\"flex:1;\">${safe(ts)}</span>`
            + (showWhy ? `<button data-eid=\"${it.id}\" class=\"ev_why\">Why?</button>` : '')
            + `<button data-eid=\"${it.id}\" class=\"ev_edit\">Edit</button>`
            + `</div>`
        }).join('');
        el.querySelectorAll('.ev_edit').forEach(btn => { btn.addEventListener('click', () => editEvent(btn.getAttribute('data-eid'))); });
        el.querySelectorAll('.ev_why').forEach(btn => { btn.addEventListener('click', () => explainEvent(btn.getAttribute('data-eid'))); });
      }
      async function loadEvents(){
        try {
          const limEl = document.getElementById('events_limit');
          const lim = limEl ? parseInt(limEl.value||'50',10) : 50;
          const j = await (await fetch(`/api/events?limit=${lim}`)).json();
          renderEventsList(j.items||[]);
        } catch(e){ console.error(e); }
      }
      async function editEvent(id){
        try {
          const ev = await (await fetch(`/api/events/${id}`)).json();
          document.getElementById('event_editor').style.display = 'block';
          document.getElementById('ev_id').textContent = `#${ev.id}`;
          document.getElementById('ev_kind').value = ev.kind || '';
          document.getElementById('ev_ts').value = ev.ts || '';
          document.getElementById('ev_meta').value = JSON.stringify(ev.meta || {}, null, 2);
          document.getElementById('event_editor').setAttribute('data-id', String(ev.id));
        } catch(e){ console.error(e); }
      }
      async function explainEvent(id){
        try {
          // Resolve spot_id from the event meta and show spot timeline
          const ev = await (await fetch(`/api/events/${encodeURIComponent(String(id))}`)).json();
          const spotId = ev && ev.meta ? (ev.meta.spot_id || '') : '';
          if (!spotId){ alert('This event has no spot_id'); return; }
          const url = `/static/spot.html?spot=${encodeURIComponent(spotId)}&event=${encodeURIComponent(String(id))}`;
          window.location.href = url;
        } catch(e){ console.error(e); alert('Unable to open spot details'); }
      }
      async function saveEvent(){
        try {
          const ed = document.getElementById('event_editor');
          const id = ed.getAttribute('data-id');
          const kind = document.getElementById('ev_kind').value || '';
          const ts = parseFloat(document.getElementById('ev_ts').value || '');
          const meta = JSON.parse(document.getElementById('ev_meta').value || '{}');
          const payload = { kind, meta };
          if (!isNaN(ts)) payload.ts = ts;
          const res = await fetch(`/api/events/${id}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          if (!res.ok){ alert('Save failed'); return; }
          await loadEvents();
          alert('Event saved');
        } catch(e){ alert('Invalid meta JSON or save failed'); console.error(e); }
      }
      // Tabs
      function escapeHtml(s){ return String(s||'').replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]||c)); }
      function tsStr(t){ try{ return new Date((t||0)*1000).toLocaleString(); }catch(e){ return String(t||''); } }
      async function refreshBaseline(){
        try{
          const el = document.getElementById('baseline_info');
          if (!el) return;
          const j = await (await fetch('/api/compare/baseline')).json();
          const ts = j && j.baseline_ts ? new Date(j.baseline_ts*1000).toLocaleString() : 'none';
          el.textContent = `Baseline: ${ts}`;
        }catch(e){ console.error(e); }
      }
      async function setBaselineNow(){
        try{ await fetch('/api/compare/baseline', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({}) }); refreshBaseline(); }catch(e){ console.error(e); }
      }
      async function clearBaseline(){
        try{ await fetch('/api/compare/clear', { method:'POST' }); refreshBaseline(); }catch(e){ console.error(e); }
      }
async function loadPerception(){
        try {
          const j = await (await fetch('/api/config')).json();
          const b = document.getElementById('phash_bits');
          const m = document.getElementById('phash_ms');
          if (b) b.value = j.PHASH_MIN_BITS != null ? j.PHASH_MIN_BITS : 14;
          if (m) m.value = j.PHASH_STABLE_MS != null ? j.PHASH_STABLE_MS : 1200;
        } catch(e){ console.error(e); }
      }
      async function savePerception(){
        try {
          const b = parseInt(document.getElementById('phash_bits').value||'14', 10);
          const m = parseInt(document.getElementById('phash_ms').value||'1200', 10);
          const res = await fetch('/api/config', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ PHASH_MIN_BITS: b, PHASH_STABLE_MS: m }) });
          if (!res.ok){ alert('Save failed'); return; }
          alert('Perception settings applied');
        } catch(e){ console.error(e); }
      }
      async function deleteEvent(){
        try {
          const ed = document.getElementById('event_editor');
          const id = ed.getAttribute('data-id');
          if (!id) return;
          if (!confirm('Delete this event?')) return;
          const res = await fetch(`/api/events/${id}`, { method:'DELETE' });
          if (!res.ok){ alert('Delete failed'); return; }
          ed.style.display = 'none'; ed.removeAttribute('data-id');
          await loadEvents();
        } catch(e){ console.error(e); }
      }
      async function loadImagesSummary(){
        try {
          const j = await (await fetch('/api/images/summary')).json();
          const el = document.getElementById('images_summary');
          if (el) el.textContent = `files=${j.files}  referenced=${j.referenced}  orphans=${j.orphans}  size=${(j.bytes/1048576).toFixed(1)} MB`;
        } catch(e){ console.error(e); }
      }
      async function cleanupOrphans(){
        try {
          if (!confirm('Delete orphan .jpg files that are not referenced by any event?')) return;
          const res = await fetch('/api/images/cleanup', { method:'POST' });
          const j = await res.json();
          alert(`Deleted ${j.deleted} files`);
          loadImagesSummary();
        } catch(e){ console.error(e); }
      }
      async function loadThumbnails(){
        try {
          const j = await (await fetch('/api/thumbnails?limit=60')).json();
          const grid = document.getElementById('thumb_grid');
          const fmt = (t)=> new Date((t||0)*1000).toLocaleString();
          grid.innerHTML = (j.items||[]).map((it)=>{
            return `<a href="${it.full}" target="_blank" title="#${it.event_id} - ${fmt(it.ts)}">`
                + `<img src="${it.thumb}" style="max-width:140px; border-radius:6px; border:1px solid #eee;"/>`
                + `</a>`;
          }).join('');
        } catch(e){ console.error(e); }
      }
refresh();
      loadZones();
      loadZonesJson();
      loadEvents();
      loadImagesSummary();
      loadPerception();
      refreshBaseline();
      async function clearAllEvents(){
        try{
          if (!confirm('Delete all events? This cannot be undone.')) return;
          let bulk = false;
          try { const r = await fetch('/api/events/clear', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({}) }); bulk = r.ok; } catch(e){}
          if (!bulk){
            const j = await (await fetch('/api/events?limit=10000')).json();
            const ids = (j.items||[]).map(it=>it.id);
            for (const id of ids){ try{ await fetch(`/api/events/${id}`, { method:'DELETE' }); }catch(e){} }
          }
          try { await fetch('/api/images/cleanup', { method:'POST' }); } catch(e){}
          await loadEvents();
          alert('Events cleared');
        }catch(e){ console.error(e); alert('Clear failed'); }
      }

    </script>
  </body>
</html>
