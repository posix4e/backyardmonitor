
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Backyard Monitor</title>
    <style>
      .muted { color:#666; }
      label { display:block; margin-top:6px; }
      input[type=number] { width: 6em; }
      /* Removed floating tooltip; use side panel instead */
      .panel-section { margin-top:16px; }
      .list { max-height:200px; overflow:auto; border:1px solid #eee; border-radius:6px; padding:4px; }
      .list-item { padding:4px 6px; border-radius:4px; cursor:pointer; display:flex; gap:6px; align-items:center; }
      .list-item:hover { background:#f5f7fa; }
      .list-item.active { background:#e8f1ff; }
      .pulse-indicator { position:absolute; border-radius:6px; box-shadow:0 0 0 2px rgba(255,0,0,0.5), 0 0 18px rgba(255,0,0,0.35); animation:pulse 1s ease-out infinite; pointer-events:none; z-index:9; }
      @keyframes pulse { 0%{ box-shadow:0 0 0 2px rgba(255,0,0,0.6), 0 0 0 rgba(255,0,0,0.0);} 70%{ box-shadow:0 0 0 6px rgba(255,0,0,0.2), 0 0 18px rgba(255,0,0,0.4);} 100%{ box-shadow:0 0 0 2px rgba(255,0,0,0.6), 0 0 0 rgba(255,0,0,0.0);} }
      .change-button { position:absolute; right:6px; top:6px; cursor:pointer; }
      .change-button.star { width:28px; height:28px; border:none; border-radius:50%;
        display:flex; align-items:center; justify-content:center;
        background: conic-gradient(#ff0040, #ff7a00, #ffd400, #38e600, #00d5ff, #6733ff, #ff33cc, #ff0040);
        color:#ffffff; font-size:16px; line-height:1; box-shadow:0 2px 8px rgba(0,0,0,0.25); }
      .compare-popup { position:absolute; background:#fff; border:1px solid #ccc; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.2); padding:8px; z-index:20; }
      .compare-popup .row { display:flex; gap:8px; }
      .compare-popup img { max-width:220px; border-radius:6px; border:1px solid #eee; }
      .compare-close { position:absolute; right:6px; top:6px; background:transparent; border:none; font-size:14px; cursor:pointer; }
      .delta-badge { position:absolute; left:6px; top:6px; background:#111; color:#fff; font-size:11px; padding:2px 6px; border-radius:10px; opacity:0.85; }
      #canvasWrap { position: relative; display: inline-block; }
      /* Improve mobile interactions */
      canvas { touch-action: none; -webkit-user-select: none; user-select: none; }
    </style>
  </head>
  <body>
    <h1>Backyard Monitor</h1>
    <div class="controls">
      <button id="btnStart" onclick="control('start')">Start</button>
      <button id="btnStop" onclick="control('stop')">Stop</button>
      <span class="muted">Spots: click/tap to add or select; drag to move; arrows to nudge; Delete to remove; drag vertices to reshape; Shift+click edge to add a point; double‑click a spot (or list entry) for details.</span>
    </div>
    <div class="row" style="margin-top:12px;">
      <div class="card">
        <div><strong>Live Frame</strong></div>
        <div id="canvasWrap">
          <canvas id="canvas" width="640" height="360"></canvas>
        </div>
        <div class="muted" id="status"></div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap: wrap;">
          <button onclick="saveZones()">Save Zones</button>
          <button onclick="clearSpots()">Clear Spots</button>
          <button id="sizeBtn" onclick="toggleSize()">Expand</button>
        </div>
        
      </div>
      <div class="card" style="min-width:420px;">
        <div style="display:flex; gap:8px; margin-bottom:8px;">
          <div><strong>Data</strong></div>
        </div>
        <div id="panel_data">
        <div class="panel-section">
          <div style="font-weight:600; margin-bottom:4px;">Spots</div>
          <div style="display:flex; gap:6px; align-items:center; margin-bottom:6px; flex-wrap:wrap;">
            <input id="spot_search" type="text" placeholder="Search spots..." style="flex:1; min-width:200px;" oninput="renderSpotList()" />
            <button onclick="compareSelected()" title="Compare selected (prev vs current)">★ Compare</button>
          </div>
          <div id="spot_list" class="list"></div>
          <div id="spot_editor" style="margin-top:8px; display:none;">
            <div style="margin-bottom:6px;">Edit Spot <span id="spot_edit_id" class="muted"></span></div>
            <label for="spot_name">Name</label>
            <input id="spot_name" type="text" style="width: 260px;" oninput="onSpotNameInput()"/>
            <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:6px;">
              <label>Min bits <input id="spot_min_bits" type="number" style="width:80px;"></label>
              <label>Stable ms <input id="spot_stable_ms" type="number" style="width:100px;"></label>
              <span id="spot_size" class="muted" style="font-size:12px;"></span>
            </div>
            <div style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap;">
              <button onclick="saveSpotSettings()">Save Spot</button>
              <button onclick="openSpotDetails()">Open Details</button>
            </div>
          </div>
        </div>
        <div><strong>Data</strong></div>
        <div style="margin-top:8px;">
          <label for="zones_json" style="font-weight:600; margin-bottom:4px; display:block;">Zones (JSON)</label>
          <textarea id="zones_json" aria-label="Zones JSON" style="width: 380px; height: 180px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;"></textarea>
          <div style="margin-top:6px; display:flex; gap:8px; flex-wrap: wrap;">
            <button onclick="loadZonesJson()">Load Zones</button>
            <button onclick="saveZonesJson()">Save Zones</button>
          </div>
        </div>
        <div style="margin-top:16px;">
          <div style="font-weight:600; margin-bottom:4px;">Events</div>
          <div style="margin-bottom:6px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <button onclick="loadEvents()">Load Events</button>
            <label for="events_limit">Limit</label>
            <input type="number" id="events_limit" name="events_limit" value="50" min="1" style="width:70px;"/>
            <button style="margin-left:auto; color:#a00;" onclick="clearAllEvents()">Clear Events</button>
          </div>
          <div id="events_list" style="max-height:180px; overflow:auto; border:1px solid #eee; padding:6px; border-radius:6px;"></div>
          <div id="event_editor" style="margin-top:8px; display:none;">
            <div style="margin-bottom:4px;">Editing Event <span id="ev_id"></span></div>
            <label for="ev_kind">Kind</label>
            <input type="text" id="ev_kind" name="ev_kind" style="width:200px;"/>
            <label for="ev_ts">Timestamp</label>
            <input type="number" step="0.001" id="ev_ts" name="ev_ts" style="width:200px;"/>
            <label for="ev_meta">Meta (JSON)</label>
            <textarea id="ev_meta" name="ev_meta" style="width: 380px; height: 120px; font-family: ui-monospace, monospace;"></textarea>
            <div style="margin-top:6px; display:flex; gap:8px;">
              <button onclick="saveEvent()">Save Event</button>
              <button onclick="deleteEvent()" style="color:#b00000;">Delete Event</button>
            </div>
          </div>
        </div>
        <div style="margin-top:16px;">
          <div style="font-weight:600; margin-bottom:4px;">Perception</div>
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <label for="phash_bits">Min bits</label>
            <input type="number" id="phash_bits" name="phash_bits" value="14" min="0" max="64" style="width:80px;"/>
            <label for="phash_ms">Stable ms</label>
            <input type="number" id="phash_ms" name="phash_ms" value="1200" min="0" style="width:100px;"/>
            <button onclick="savePerception()">Apply</button>
          </div>
        </div>
        <div style="margin-top:16px;">
          <div style="font-weight:600; margin-bottom:4px;">Images</div>
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:6px;">
            <button onclick="loadImagesSummary()">Refresh Summary</button>
            <button onclick="cleanupOrphans()">Cleanup Orphans</button>
            <button onclick="loadThumbnails()">Show Latest Thumbnails</button>
          </div>
          <div id="images_summary" class="muted"></div>
          <div id="thumb_grid" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:8px; max-height:320px; overflow:auto;"></div>
        </div>
        </div>
        </div>
        </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      let spots = []; // [{id,name,polygon:[[x,y],...]}]
      let selectedSpotId = null;
      const DEFAULT_SPOT = { w: 120, h: 200 };
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const canvasWrap = document.getElementById('canvasWrap');
      // Spots panel elements
      const spotSearchInput = document.getElementById('spot_search');
      const spotListEl = document.getElementById('spot_list');
      const spotEditor = document.getElementById('spot_editor');
      const spotEditIdEl = document.getElementById('spot_edit_id');
      const spotNameInput = document.getElementById('spot_name');
      const spotMinBitsInput = document.getElementById('spot_min_bits');
      const spotStableMsInput = document.getElementById('spot_stable_ms');
      const spotSizeEl = document.getElementById('spot_size');
      let baseW = 0, baseH = 0; // native frame size from backend
      const initW = canvas.width, initH = canvas.height; // initial canvas size (shrink target)
      let expanded = false; // false => 640x360, true => full native size
      let hoverSpotId = null; // track hover for selection hint
      // Pointer/touch drag state
      let dragging = false;
      let dragSpotId = null;
      let draggingVertexIndex = null; // if not null, dragging a specific vertex of selected spot
      let dragStart = null; // {x,y} in native coords
      let dragStartPoly = null; // deep copy of polygon at start
      let downOnEmpty = false; // distinguish tap-to-add

      function screenToNative(clientX, clientY){
        const rect = canvas.getBoundingClientRect();
        const sx = baseW ? (baseW / canvas.width) : 1;
        const sy = baseH ? (baseH / canvas.height) : 1;
        const x = Math.round((clientX - rect.left) * sx);
        const y = Math.round((clientY - rect.top) * sy);
        return { x, y };
      }

      function nativeToScreen(x, y){
        const sx = baseW ? (canvas.width / baseW) : 1;
        const sy = baseH ? (canvas.height / baseH) : 1;
        return { x: x * sx, y: y * sy };
      }

      function polyBBox(poly){
        if (!poly || !poly.length) return null;
        const xs = poly.map(p=>p[0]); const ys = poly.map(p=>p[1]);
        const x1 = Math.min(...xs), x2 = Math.max(...xs), y1 = Math.min(...ys), y2 = Math.max(...ys);
        return { x1, y1, x2, y2 };
      }

      function hitSpotAt(x, y, tolPx=0){
        // tolPx in screen px; convert to native units using average scale
        const sx = baseW ? (baseW / canvas.width) : 1;
        const sy = baseH ? (baseH / canvas.height) : 1;
        const tol = Math.max(0, Math.round((tolPx * (sx + sy)) / 2));
        for (let i=(spots||[]).length-1; i>=0; i--){
          const s = spots[i];
          const bb = polyBBox(s.polygon);
          const insidePoly = pointInPoly([x,y], s.polygon);
          const insideBBox = bb ? (x >= (bb.x1 - tol) && x <= (bb.x2 + tol) && y >= (bb.y1 - tol) && y <= (bb.y2 + tol)) : false;
          if (insidePoly || insideBBox) return s;
        }
        return null;
      }

      function vertexNear(s, x, y, tolPx){
        if (!s || !s.polygon) return -1;
        // compare in screen space for tolerance
        const p = nativeToScreen(x, y);
        for (let i=0;i<s.polygon.length;i++){
          const v = s.polygon[i];
          const vs = nativeToScreen(v[0], v[1]);
          const dx = vs.x - p.x, dy = vs.y - p.y;
          const d2 = dx*dx + dy*dy;
          if (d2 <= (tolPx*tolPx)) return i;
        }
        return -1;
      }

      function _distToSegSq(px, py, x1, y1, x2, y2){
        const vx = x2 - x1, vy = y2 - y1;
        const wx = px - x1, wy = py - y1;
        const c1 = vx*wx + vy*wy;
        if (c1 <= 0) return (px-x1)*(px-x1) + (py-y1)*(py-y1);
        const c2 = vx*vx + vy*vy;
        if (c2 <= c1) return (px-x2)*(px-x2) + (py-y2)*(py-y2);
        const b = c1 / c2;
        const bx = x1 + b*vx, by = y1 + b*vy;
        return (px-bx)*(px-bx) + (py-by)*(py-by);
      }

      function edgeNear(s, x, y, tolPx){
        if (!s || !s.polygon || s.polygon.length < 2) return -1;
        // work in screen space
        const p = nativeToScreen(x, y);
        for (let i=0;i<s.polygon.length;i++){
          const a = s.polygon[i];
          const b = s.polygon[(i+1)%s.polygon.length];
          const as = nativeToScreen(a[0], a[1]);
          const bs = nativeToScreen(b[0], b[1]);
          const d2 = _distToSegSq(p.x, p.y, as.x, as.y, bs.x, bs.y);
          if (d2 <= tolPx*tolPx) return i; // edge between i and i+1
        }
        return -1;
      }

      function applySize(){
        // If expanded and we know native size, use it; otherwise stay at initial size
        if (expanded && baseW && baseH){
          canvas.width = baseW;
          canvas.height = baseH;
        } else {
          canvas.width = initW;
          canvas.height = initH;
        }
        const btn = document.getElementById('sizeBtn');
        if (btn) btn.textContent = expanded ? 'Shrink' : 'Expand';
      }

      async function control(action) {
        const bStart = document.getElementById('btnStart');
        const bStop = document.getElementById('btnStop');
        try {
          if (bStart) bStart.disabled = true;
          if (bStop) bStop.disabled = true;
          const res = await fetch('/api/control?action=' + encodeURIComponent(action), { method: 'POST' });
          if (!res.ok) {
            const txt = await res.text();
            alert('Control failed: ' + txt);
          }
          // give the worker a moment to spin up/down
          await new Promise(r => setTimeout(r, 400));
          await refresh();
        } catch (e) {
          console.error(e);
          alert('Control error: ' + (e && e.message ? e.message : e));
        } finally {
          if (bStart) bStart.disabled = false;
          if (bStop) bStop.disabled = false;
        }
      }
      async function refresh() {
        const status = await (await fetch('/api/status')).json();
        document.getElementById('status').innerText = `running=${status.running} last_ts=${status.last_ts} size=${status.width}x${status.height}`;
        if (status.width && status.height) {
          baseW = status.width; baseH = status.height;
        }
        // Apply the current sizing preference
        applySize();
      }

      function rectPolygon(cx, cy, w, h) {
        const x0 = cx - w/2, y0 = cy - h/2;
        return [ [x0,y0], [x0+w,y0], [x0+w,y0+h], [x0,y0+h] ];
      }
      function pointInPoly(pt, poly) {
        let [x, y] = pt; let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i][0], yi = poly[i][1];
          const xj = poly[j][0], yj = poly[j][1];
          const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function deleteSelected(){
        if (!selectedSpotId) return;
        spots = spots.filter(sp => sp.id !== selectedSpotId);
        selectedSpotId = null;
        renderSpotList(); fillSpotEditor();
        draw();
      }

      function rotateSelected(deg){
        if (!selectedSpotId) return;
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (!s || !s.polygon || s.polygon.length < 3) return;
        const xs = s.polygon.map(p=>p[0]); const ys = s.polygon.map(p=>p[1]);
        const cx = (Math.min(...xs) + Math.max(...xs)) / 2;
        const cy = (Math.min(...ys) + Math.max(...ys)) / 2;
        const ang = (deg * Math.PI) / 180;
        const ca = Math.cos(ang), sa = Math.sin(ang);
        s.polygon = s.polygon.map(([px,py]) => {
          const dx = px - cx, dy = py - cy;
          const rx = dx*ca - dy*sa; const ry = dx*sa + dy*ca;
          return [cx + rx, cy + ry];
        });
        fillSpotEditor();
        draw();
      }

      function updateSpotName(name){
        if (!selectedSpotId) return;
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (s) { s.name = (name || '').trim() || s.id; renderSpotList(); fillSpotEditor(); draw(); }
      }

      function selectedBBox(){
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (!s || !s.polygon || s.polygon.length < 3) return null;
        const xs = s.polygon.map(p=>p[0]); const ys = s.polygon.map(p=>p[1]);
        const x1 = Math.min(...xs), x2 = Math.max(...xs), y1 = Math.min(...ys), y2 = Math.max(...ys);
        return { x: x1, y: y1, w: x2-x1, h: y2-y1, name: s.name || s.id };
      }

      // Spots panel rendering and editing
      function renderSpotList(){
        if (!spotListEl) return;
        const q = (spotSearchInput && spotSearchInput.value || '').toLowerCase();
        const items = (spots||[]).filter(sp => {
          const t = ((sp.id||'') + ' ' + (sp.name||'')).toLowerCase();
          return !q || t.includes(q);
        });
        spotListEl.innerHTML = '';
        for (const sp of items){
          const div = document.createElement('div');
          div.className = 'list-item' + (sp.id === selectedSpotId ? ' active' : '');
          div.innerHTML = `<span class="muted" style="font-size:12px;">${sp.id}</span> <span>${(sp.name||sp.id)}</span>`;
          div.onclick = () => { selectedSpotId = sp.id; fillSpotEditor(); draw(); renderSpotList(); };
          div.ondblclick = () => { const url = `/static/spot.html?spot=${encodeURIComponent(sp.id)}`; window.open(url, '_blank'); };
          spotListEl.appendChild(div);
        }
      }

      function fillSpotEditor(){
        if (!spotEditor) return;
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (!s){ spotEditor.style.display = 'none'; return; }
        spotEditor.style.display = 'block';
        if (spotEditIdEl) spotEditIdEl.textContent = s.id;
        if (spotNameInput) spotNameInput.value = s.name || s.id;
        const box = selectedBBox();
        if (spotSizeEl) spotSizeEl.textContent = box ? `${Math.round(box.w)}×${Math.round(box.h)} px` : '';
        (async () => {
          try {
            const z = await (await fetch('/api/zones')).json();
            const cfg = (z.spots||[]).find(sp=>sp.id===selectedSpotId) || {};
            if (spotMinBitsInput) spotMinBitsInput.value = cfg.min_bits != null ? cfg.min_bits : '';
            if (spotStableMsInput) spotStableMsInput.value = cfg.stable_ms != null ? cfg.stable_ms : '';
          } catch(e) {}
        })();
      }

      function onSpotNameInput(){ updateSpotName(spotNameInput ? spotNameInput.value : ''); }

      async function saveSpotSettings(){
        if (!selectedSpotId) return;
        try {
          const newName = spotNameInput ? (spotNameInput.value||'') : '';
          const minBits = spotMinBitsInput && spotMinBitsInput.value !== '' ? parseInt(spotMinBitsInput.value,10) : null;
          const stableMs = spotStableMsInput && spotStableMsInput.value !== '' ? parseInt(spotStableMsInput.value,10) : null;
          const z = await (await fetch('/api/zones')).json();
          const spotsZ = z.spots || [];
          for (const sp of spotsZ){ if (sp.id === selectedSpotId){ sp.name = newName || sp.id; if (minBits!==null) sp.min_bits = minBits; else delete sp.min_bits; if (stableMs!==null) sp.stable_ms = stableMs; else delete sp.stable_ms; break; } }
          await fetch('/api/zones', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ spots: spotsZ }) });
          for (let i=0;i<spots.length;i++){ if (spots[i].id === selectedSpotId){ spots[i].name = newName || spots[i].id; break; } }
          renderSpotList();
        } catch(e) { console.error(e); }
      }

      function openSpotDetails(){
        if (!selectedSpotId) return;
        const url = `/static/spot.html?spot=${encodeURIComponent(selectedSpotId)}`;
        window.open(url, '_blank');
      }

      function compareSelected(){
        if (!selectedSpotId) return;
        try {
          const box = selectedBBox();
          const r = box ? bboxToScreen(Math.round(box.x), Math.round(box.y), Math.round(box.x+box.w), Math.round(box.y+box.h)) : {x:0,y:0,w:0,h:0};
          const sid = selectedSpotId;
          const prevUrl = (window.spotPrev && window.spotPrev[sid]) || null;
          const curUrl = `/api/spot.jpg?id=${encodeURIComponent(sid)}&w=240&ts=${Date.now()}`;
          const prevSig = (window.spotPrevSig && window.spotPrevSig[sid]) || null;
          const curSig = (window.lastSigMap && window.lastSigMap[sid]) || null;
          showComparisonPopup(sid, r, prevUrl, curUrl, prevSig, curSig);
        } catch(err) { console.error(err); }
      }

      function toggleSize(){
        expanded = !expanded;
        applySize();
        draw();
      }

      // Pointer/touch + mouse unified interactions
      function updateHover(clientX, clientY){
        const {x, y} = screenToNative(clientX, clientY);
        const hit = hitSpotAt(x, y, 6);
        const newHover = hit ? hit.id : null;
        if (newHover !== hoverSpotId){
          hoverSpotId = newHover;
          canvasWrap.style.cursor = hoverSpotId ? 'pointer' : 'default';
          draw();
        }
      }

      canvas.addEventListener('pointerdown', (e) => {
        try { canvas.setPointerCapture(e.pointerId); } catch(err) {}
        downOnEmpty = false;
        const {x, y} = screenToNative(e.clientX, e.clientY);
        const isTouch = e.pointerType === 'touch';
        const hit = hitSpotAt(x, y, isTouch ? 16 : 6);
        if (hit){
          selectedSpotId = hit.id;
          fillSpotEditor(); renderSpotList();
          const s = spots.find(sp => sp.id === hit.id);
          // Shift+click near edge to insert a new vertex
          if (e.shiftKey && s){
            const ei = edgeNear(s, x, y, isTouch ? 24 : 10);
            if (ei >= 0){
              s.polygon.splice(ei+1, 0, [x, y]);
              draw();
              e.preventDefault();
              return;
            }
          }
          // If near a vertex, drag that vertex
          const vi = s ? vertexNear(s, x, y, isTouch ? 20 : 10) : -1;
          if (vi >= 0){
            dragging = true; dragSpotId = hit.id; draggingVertexIndex = vi; dragStart = null; dragStartPoly = null;
          } else {
            // Drag whole shape
            dragging = true; dragSpotId = hit.id; dragStart = {x, y};
            dragStartPoly = s && s.polygon ? s.polygon.map(p => [p[0], p[1]]) : null;
          }
        } else {
          // Track that we pressed on empty space to allow tap-to-add on pointerup
          downOnEmpty = true;
        }
        e.preventDefault();
      }, { passive: false });

      canvas.addEventListener('pointermove', (e) => {
        if (!dragging){ updateHover(e.clientX, e.clientY); return; }
        if (!dragSpotId) return;
        const {x, y} = screenToNative(e.clientX, e.clientY);
        const s = spots.find(sp => sp.id === dragSpotId);
        if (!s) return;
        if (draggingVertexIndex !== null && draggingVertexIndex >= 0){
          s.polygon[draggingVertexIndex] = [x, y];
          draw();
        } else if (dragStart && dragStartPoly){
          const dx = x - dragStart.x; const dy = y - dragStart.y;
          s.polygon = dragStartPoly.map(p => [p[0] + dx, p[1] + dy]);
          draw();
        }
        e.preventDefault();
      }, { passive: false });

      function endPointer(e){
        const wasDragging = dragging;
        const wasDownOnEmpty = downOnEmpty;
        const {x, y} = screenToNative(e.clientX, e.clientY);
        // Reset drag state first
        dragging = false; dragSpotId = null; draggingVertexIndex = null; dragStart = null; dragStartPoly = null;
        try { canvas.releasePointerCapture(e.pointerId); } catch(err) {}
        // If it was a tap on empty, add a new spot
        if (!wasDragging && wasDownOnEmpty){
          const id = 'spot_' + (spots.length + 1);
          let poly = rectPolygon(x, y, DEFAULT_SPOT.w, DEFAULT_SPOT.h);
          spots.push({ id, name: id, polygon: poly });
          selectedSpotId = id; fillSpotEditor(); renderSpotList(); renderZonesView(); draw();
        } else if (!wasDragging) {
          // It was a tap over an existing spot: select it
          const hit = hitSpotAt(x, y, e.pointerType === 'touch' ? 16 : 6);
          if (hit){ selectedSpotId = hit.id; fillSpotEditor(); renderSpotList(); draw(); }
        }
        e.preventDefault();
      }
      canvas.addEventListener('pointerup', endPointer, { passive: false });
      canvas.addEventListener('pointercancel', endPointer, { passive: false });

      // Maintain hover feedback for mouse users when not dragging
      canvas.addEventListener('mouseleave', () => { hoverSpotId = null; canvasWrap.style.cursor = 'default'; draw(); });


      async function draw() {
        // draw latest frame
        const img = new Image();
        let retries = 0;
        img.onload = () => {
          try {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          } catch(e) {}
          // overlay spots as rectangles
          if (spots && spots.length) {
            ctx.strokeStyle = '#44aaff'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(68,170,255,0.12)';
            for (const s of spots) {
              if (!s.polygon || s.polygon.length < 4) continue;
              const sx = baseW ? (canvas.width / baseW) : 1;
              const sy = baseH ? (canvas.height / baseH) : 1;
              const p0 = s.polygon[0];
              ctx.beginPath(); ctx.moveTo(p0[0]*sx, p0[1]*sy);
              for (let i=1;i<s.polygon.length;i++){ const p = s.polygon[i]; ctx.lineTo(p[0]*sx, p[1]*sy); }
              ctx.closePath(); ctx.stroke(); ctx.fill();
              if (s.id === selectedSpotId) {
                ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2; ctx.setLineDash([6,4]);
                ctx.stroke(); ctx.setLineDash([]); ctx.strokeStyle = '#44aaff';
                // draw vertex handles
                try {
                  ctx.save();
                  for (let i=0;i<s.polygon.length;i++){
                    const v = s.polygon[i];
                    const vx = v[0]*sx, vy = v[1]*sy;
                    ctx.beginPath();
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 2;
                    ctx.arc(vx, vy, 5, 0, Math.PI*2);
                    ctx.fill(); ctx.stroke();
                  }
                  ctx.restore();
                } catch(e) {}
              }
            }
          }
          fillSpotEditor();
        };
        img.onerror = () => {
          // quick retry once to reduce visible grey on transient errors
          if (retries < 1) {
            retries++;
            setTimeout(() => { img.src = '/frame.jpg?ts=' + Date.now(); }, 200);
          }
        };
        img.src = '/frame.jpg?ts=' + Date.now();
      }

      // Mouse click remains for old browsers; pointer handlers will handle most cases
      canvas.addEventListener('click', async (e) => {
        const {x, y} = screenToNative(e.clientX, e.clientY);
        const hit = hitSpotAt(x, y, 6);
        if (hit) { selectedSpotId = hit.id; fillSpotEditor(); renderSpotList(); }
        else {
          const id = 'spot_' + (spots.length + 1);
          let poly = rectPolygon(x, y, DEFAULT_SPOT.w, DEFAULT_SPOT.h);
          spots.push({ id, name: id, polygon: poly });
          selectedSpotId = id; fillSpotEditor(); renderSpotList();
        }
        renderZonesView(); draw();
      });

      // Double-click to open spot details page
      canvas.addEventListener('dblclick', (e) => {
        const {x, y} = screenToNative(e.clientX, e.clientY);
        const hit = hitSpotAt(x, y, 8);
        if (hit){
          const url = `/static/spot.html?spot=${encodeURIComponent(hit.id)}`;
          window.open(url, '_blank');
        }
      });

      document.addEventListener('keydown', (e) => {
        if (!selectedSpotId) return;
        const s = spots.find(sp => sp.id === selectedSpotId);
        if (!s) return;
        const step = (e.shiftKey ? 10 : 5);
        if (e.key === 'Delete' || e.key === 'Backspace') {
          spots = spots.filter(sp => sp.id !== selectedSpotId);
          selectedSpotId = null; renderZonesView(); renderSpotList(); fillSpotEditor(); draw(); e.preventDefault(); return;
        }
        let dx = 0, dy = 0;
        if (e.key === 'ArrowLeft') dx = -step;
        else if (e.key === 'ArrowRight') dx = step;
        else if (e.key === 'ArrowUp') dy = -step;
        else if (e.key === 'ArrowDown') dy = step;
        if (dx || dy) {
          s.polygon = s.polygon.map(p => [p[0] + dx, p[1] + dy]);
          renderZonesView(); draw(); e.preventDefault();
        }
      });

      async function saveZones(){
        const payload = { spots };
        await fetch('/api/zones', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        alert('Saved');
        renderSpotList();
      }

      async function loadZones(){
        const res = await fetch('/api/zones');
        const z = await res.json();
        spots = z.spots || [];
        renderZonesView();
        renderSpotList();
        fillSpotEditor();
      }

      function clearSpots(){ spots = []; selectedSpotId = null; renderSpotList(); fillSpotEditor(); draw(); }
      function renderZonesView(){ /* we keep homepage minimal; could add JSON preview if desired */ }

      // Slow down frame refresh to reduce flicker while editing
      if (window.__bm_drawInt) { try { clearInterval(window.__bm_drawInt); } catch (e) {} }
      window.__bm_drawInt = setInterval(() => { draw(); }, 1000);
      // Track last phash per spot for change detection
      let lastSigMap = {};
      // Cache previous image URL per spot from aggregated API
      let spotPrev = {};
      let spotPrevSig = {};
      async function refreshSpotPrev(){
        try {
          const j = await (await fetch('/api/spot_recent?per_spot=2&scan_limit=200')).json();
          const m = {};
          const m2 = {};
          for (const it of (j.items||[])){
            if (it.prev_url) m[it.spot_id] = it.prev_url;
            if (it.prev_sig) m2[it.spot_id] = it.prev_sig;
          }
          spotPrev = m; spotPrevSig = m2;
          try { window.spotPrev = spotPrev; window.spotPrevSig = spotPrevSig; } catch(e){}
        } catch(e) { /* ignore */ }
      }
      refreshSpotPrev();
      if (window.__bm_recentInt) { try { clearInterval(window.__bm_recentInt); } catch (e) {} }
      window.__bm_recentInt = setInterval(refreshSpotPrev, 10000);
      // Poll spot stats to detect changes and show effect
      if (window.__bm_statInt) { try { clearInterval(window.__bm_statInt); } catch (e) {} }
      window.__bm_statInt = setInterval(async () => {
        try {
          const stats = await (await fetch('/api/spot_stats')).json();
          const items = (stats && stats.spots) || [];
          for (const st of items){
            const prev = lastSigMap[st.id] || '';
            const cur = st.sig || '';
            if (prev && cur && prev !== cur) {
              try { showSpotChangeEffect(st); } catch (e) { console.error(e); }
            }
            if (cur) lastSigMap[st.id] = cur;
            try { window.lastSigMap = lastSigMap; } catch(e){}
          }
        } catch (e) { /* ignore transient errors */ }
      }, 2000);

      function bboxToScreen(x1,y1,x2,y2){
        if (!baseW || !baseH) return null;
        const sx = canvas.width / baseW, sy = canvas.height / baseH;
        const rx1 = Math.round(x1 * sx), ry1 = Math.round(y1 * sy);
        const rw = Math.round((x2 - x1) * sx), rh = Math.round((y2 - y1) * sy);
        return { x: rx1, y: ry1, w: rw, h: rh };
      }

      function showSpotChangeEffect(st){
        // st has x1,y1,x2,y2 from /api/spot_stats
        const rect = bboxToScreen(st.x1, st.y1, st.x2, st.y2);
        if (!rect || rect.w <= 4 || rect.h <= 4) return;
        const el = document.createElement('div');
        el.className = 'pulse-indicator';
        el.style.left = rect.x + 'px';
        el.style.top = rect.y + 'px';
        el.style.width = Math.max(12, rect.w) + 'px';
        el.style.height = Math.max(12, rect.h) + 'px';
        canvasWrap.appendChild(el);
        // Setup auto-remove handlers first so we can safely reference cleanup/t below
        let removed = false;
        const cleanup = () => { if (!removed) { removed = true; el.remove(); } };
        let t = setTimeout(cleanup, 4000);
        el.addEventListener('mouseenter', () => { try { clearTimeout(t); } catch (e) {} });
        el.addEventListener('mouseleave', () => { t = setTimeout(cleanup, 1500); });

        // Show delta bits badge (computed from last phash vs current)
        try {
          const prevSig = (lastSigMap && lastSigMap[st.id]) || '';
          const curSig = st.sig || '';
          const d = hamming(prevSig, curSig);
          if (d !== null){
            const badge = document.createElement('div');
            badge.className = 'delta-badge';
            badge.textContent = `Δ ${d}`;
            el.appendChild(badge);
          }
        } catch(e){}
        // Compare UI is handled in the single spot toolbar (no separate star overlay)
      }

      function hamming(a, b){ if (!a || !b || a.length !== b.length) return null; let d=0; for(let i=0;i<a.length;i++){ if(a[i]!==b[i]) d++; } return d; }
      async function showComparisonPopup(spotId, rect, prevUrl=null, curUrl=null, prevSig=null, curSig=null){
        // remove existing popup
        document.querySelectorAll('.compare-popup').forEach(n=>n.remove());
        // fetch previous event (most recent) for this spot
        if (!prevUrl) {
          try {
            const j = await (await fetch(`/api/spot_history?spot_id=${encodeURIComponent(spotId)}&limit=2`)).json();
            if (j && j.items && j.items.length >= 2) {
              const prev = j.items[1];
              prevUrl = (prev && (prev.crop || prev.thumb)) || null;
            } else if (j && j.items && j.items.length === 1) {
              const prev = j.items[0];
              prevUrl = (prev && (prev.crop || prev.thumb)) || null;
            }
          } catch {}
        }
        if (!curUrl) {
          curUrl = `/api/spot.jpg?id=${encodeURIComponent(spotId)}&ts=${Date.now()}`;
        }
        const curSigEff = curSig || (lastSigMap && lastSigMap[spotId]) || '';
        const deltaBits = (prevSig && curSigEff && prevSig.length===curSigEff.length) ? hamming(prevSig, curSigEff) : null;
        const pop = document.createElement('div');
        pop.className = 'compare-popup';
        pop.style.left = Math.max(8, Math.min(canvas.width - 480, rect.x)) + 'px';
        pop.style.top = Math.max(8, Math.min(canvas.height - 260, rect.y)) + 'px';
        pop.innerHTML = `
          <button class="compare-close" title="Close">&times;</button>
          <div style="font-weight:600; margin-bottom:6px;">Spot ${spotId} change</div>
          <div class="muted" style="margin-bottom:6px;">phash prev: ${prevSig?prevSig:'-'} &bull; current: ${curSigEff?curSigEff:'-'} ${deltaBits!==null?('&bull; Delta bits: '+deltaBits):''}</div>
          <div class="row">
            <div>
              <div class="muted" style="margin-bottom:4px;">Previous</div>
              <img src="${prevUrl || ''}" alt="previous" onerror="this.style.display='none'"/>
            </div>
            <div>
              <div class="muted" style="margin-bottom:4px;">Current</div>
              <img src="${curUrl}" alt="current"/>
            </div>
          </div>`;
        const close = () => { try { pop.remove(); } catch (e) {} };
        pop.querySelector('.compare-close').addEventListener('click', close);
        // Close on outside click
        const onDoc = (e) => { if (!pop.contains(e.target)) { close(); document.removeEventListener('mousedown', onDoc); } };
        document.addEventListener('mousedown', onDoc);
        canvasWrap.appendChild(pop);
      }
      // Generic data panel helpers
      async function loadZonesJson(){
        try {
          const z = await (await fetch('/api/zones')).json();
          const ta = document.getElementById('zones_json');
          if (ta) ta.value = JSON.stringify(z, null, 2);
        } catch(e){ console.error(e); }
      }
      async function saveZonesJson(){
        try {
          const ta = document.getElementById('zones_json');
          const obj = JSON.parse(ta.value || '{}');
          await fetch('/api/zones', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(obj) });
          // also update overlay spots so canvas reflects saved data
          if (obj && Array.isArray(obj.spots)) { spots = obj.spots; selectedSpotId = null; draw(); }
          alert('Zones saved');
        } catch(e){ alert('Invalid JSON or save failed'); console.error(e); }
      }
      function renderEventsList(items){
        const el = document.getElementById('events_list');
        const safe = (t) => String(t||'').replace(/[&<>]/g, (c)=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]||c));
        el.innerHTML = (items||[]).map((it)=>{
          const ts = new Date((it.ts||0)*1000).toLocaleString();
          const hasSpot = !!(it && it.meta && it.meta.spot_id);
          const isSpotChange = String(it && it.kind || '').toLowerCase() === 'spot_change';
          const showWhy = hasSpot && isSpotChange;
          return `<div style=\"display:flex; align-items:center; gap:8px; padding:4px 0; border-bottom:1px solid #f2f2f2;\">`
            + `<span style=\"width:56px;\">#${it.id}</span>`
            + `<span style=\"flex:1;\">${safe(it.kind)}</span>`
            + `<span class=\"muted\" style=\"flex:1;\">${safe(ts)}</span>`
            + (showWhy ? `<button data-eid=\"${it.id}\" class=\"ev_why\">Why?</button>` : '')
            + `<button data-eid=\"${it.id}\" class=\"ev_edit\">Edit</button>`
            + `</div>`
        }).join('');
        el.querySelectorAll('.ev_edit').forEach(btn => { btn.addEventListener('click', () => editEvent(btn.getAttribute('data-eid'))); });
        el.querySelectorAll('.ev_why').forEach(btn => { btn.addEventListener('click', () => explainEvent(btn.getAttribute('data-eid'))); });
      }
      async function loadEvents(){
        try {
          const limEl = document.getElementById('events_limit');
          const lim = limEl ? parseInt(limEl.value||'50',10) : 50;
          const j = await (await fetch(`/api/events?limit=${lim}`)).json();
          renderEventsList(j.items||[]);
        } catch(e){ console.error(e); }
      }
      async function editEvent(id){
        try {
          const ev = await (await fetch(`/api/events/${id}`)).json();
          document.getElementById('event_editor').style.display = 'block';
          document.getElementById('ev_id').textContent = `#${ev.id}`;
          document.getElementById('ev_kind').value = ev.kind || '';
          document.getElementById('ev_ts').value = ev.ts || '';
          document.getElementById('ev_meta').value = JSON.stringify(ev.meta || {}, null, 2);
          document.getElementById('event_editor').setAttribute('data-id', String(ev.id));
        } catch(e){ console.error(e); }
      }
      async function explainEvent(id){
        try {
          // Resolve spot_id from the event meta and show spot timeline
          const ev = await (await fetch(`/api/events/${encodeURIComponent(String(id))}`)).json();
          const spotId = ev && ev.meta ? (ev.meta.spot_id || '') : '';
          if (!spotId){ alert('This event has no spot_id'); return; }
          const url = `/static/spot.html?spot=${encodeURIComponent(spotId)}&event=${encodeURIComponent(String(id))}`;
          window.location.href = url;
        } catch(e){ console.error(e); alert('Unable to open spot details'); }
      }
      async function saveEvent(){
        try {
          const ed = document.getElementById('event_editor');
          const id = ed.getAttribute('data-id');
          const kind = document.getElementById('ev_kind').value || '';
          const ts = parseFloat(document.getElementById('ev_ts').value || '');
          const meta = JSON.parse(document.getElementById('ev_meta').value || '{}');
          const payload = { kind, meta };
          if (!isNaN(ts)) payload.ts = ts;
          const res = await fetch(`/api/events/${id}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          if (!res.ok){ alert('Save failed'); return; }
          await loadEvents();
          alert('Event saved');
        } catch(e){ alert('Invalid meta JSON or save failed'); console.error(e); }
      }
      // Tabs
      function escapeHtml(s){ return String(s||'').replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]||c)); }
      function tsStr(t){ try{ return new Date((t||0)*1000).toLocaleString(); }catch(e){ return String(t||''); } }
      async function refreshBaseline(){
        try{
          const el = document.getElementById('baseline_info');
          if (!el) return;
          const j = await (await fetch('/api/compare/baseline')).json();
          const ts = j && j.baseline_ts ? new Date(j.baseline_ts*1000).toLocaleString() : 'none';
          el.textContent = `Baseline: ${ts}`;
        }catch(e){ console.error(e); }
      }
      async function setBaselineNow(){
        try{ await fetch('/api/compare/baseline', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({}) }); refreshBaseline(); }catch(e){ console.error(e); }
      }
      async function clearBaseline(){
        try{ await fetch('/api/compare/clear', { method:'POST' }); refreshBaseline(); }catch(e){ console.error(e); }
      }
async function loadPerception(){
        try {
          const j = await (await fetch('/api/config')).json();
          const b = document.getElementById('phash_bits');
          const m = document.getElementById('phash_ms');
          if (b) b.value = j.PHASH_MIN_BITS != null ? j.PHASH_MIN_BITS : 14;
          if (m) m.value = j.PHASH_STABLE_MS != null ? j.PHASH_STABLE_MS : 1200;
        } catch(e){ console.error(e); }
      }
      async function savePerception(){
        try {
          const b = parseInt(document.getElementById('phash_bits').value||'14', 10);
          const m = parseInt(document.getElementById('phash_ms').value||'1200', 10);
          const res = await fetch('/api/config', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ PHASH_MIN_BITS: b, PHASH_STABLE_MS: m }) });
          if (!res.ok){ alert('Save failed'); return; }
          alert('Perception settings applied');
        } catch(e){ console.error(e); }
      }
      async function deleteEvent(){
        try {
          const ed = document.getElementById('event_editor');
          const id = ed.getAttribute('data-id');
          if (!id) return;
          if (!confirm('Delete this event?')) return;
          const res = await fetch(`/api/events/${id}`, { method:'DELETE' });
          if (!res.ok){ alert('Delete failed'); return; }
          ed.style.display = 'none'; ed.removeAttribute('data-id');
          await loadEvents();
        } catch(e){ console.error(e); }
      }
      async function loadImagesSummary(){
        try {
          const j = await (await fetch('/api/images/summary')).json();
          const el = document.getElementById('images_summary');
          if (el) el.textContent = `files=${j.files}  referenced=${j.referenced}  orphans=${j.orphans}  size=${(j.bytes/1048576).toFixed(1)} MB`;
        } catch(e){ console.error(e); }
      }
      async function cleanupOrphans(){
        try {
          if (!confirm('Delete orphan .jpg files that are not referenced by any event?')) return;
          const res = await fetch('/api/images/cleanup', { method:'POST' });
          const j = await res.json();
          alert(`Deleted ${j.deleted} files`);
          loadImagesSummary();
        } catch(e){ console.error(e); }
      }
      async function loadThumbnails(){
        try {
          const j = await (await fetch('/api/thumbnails?limit=60')).json();
          const grid = document.getElementById('thumb_grid');
          const fmt = (t)=> new Date((t||0)*1000).toLocaleString();
          grid.innerHTML = (j.items||[]).map((it)=>{
            return `<a href="${it.full}" target="_blank" title="#${it.event_id} - ${fmt(it.ts)}">`
                + `<img src="${it.thumb}" style="max-width:140px; border-radius:6px; border:1px solid #eee;"/>`
                + `</a>`;
          }).join('');
        } catch(e){ console.error(e); }
      }
refresh();
      loadZones();
      loadZonesJson();
      loadEvents();
      loadImagesSummary();
      loadPerception();
      refreshBaseline();
      async function clearAllEvents(){
        try{
          if (!confirm('Delete all events? This cannot be undone.')) return;
          let bulk = false;
          try { const r = await fetch('/api/events/clear', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({}) }); bulk = r.ok; } catch(e){}
          if (!bulk){
            const j = await (await fetch('/api/events?limit=10000')).json();
            const ids = (j.items||[]).map(it=>it.id);
            for (const id of ids){ try{ await fetch(`/api/events/${id}`, { method:'DELETE' }); }catch(e){} }
          }
          try { await fetch('/api/images/cleanup', { method:'POST' }); } catch(e){}
          await loadEvents();
          alert('Events cleared');
        }catch(e){ console.error(e); alert('Clear failed'); }
      }

    </script>
  </body>
</html>
